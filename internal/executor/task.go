package executor

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/google/uuid"
	"github.com/stellarlink/pilot-swe/internal/config"
	"github.com/stellarlink/pilot-swe/internal/github"
	"github.com/stellarlink/pilot-swe/internal/provider"
	"github.com/stellarlink/pilot-swe/internal/store"
)

// Task represents a code generation task
type Task struct {
	Owner       string
	Repo        string
	IssueNumber int
	IssueTitle  string
	IssueBody   string
	User        string
	CommentID   int64
}

// Executor orchestrates the code generation workflow
type Executor struct {
	cfg       *config.Config
	provider  provider.Provider
	ghOps     *github.Operations
	taskStore *store.TaskStore
}

// NewExecutor creates a new executor
func NewExecutor(cfg *config.Config, taskStore *store.TaskStore) (*Executor, error) {
	p, err := provider.NewProvider(cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to create provider: %w", err)
	}

	ghOps, err := github.NewOperations(cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to create github operations: %w", err)
	}

	return &Executor{
		cfg:       cfg,
		provider:  p,
		ghOps:     ghOps,
		taskStore: taskStore,
	}, nil
}

// Execute runs the full code generation workflow
func (e *Executor) Execute(ctx context.Context, task *Task) error {
	// Create task record
	taskID := generateTaskID(task)
	storeTask := &store.Task{
		ID:          taskID,
		Title:       task.IssueTitle,
		Status:      store.StatusPending,
		Owner:       task.Owner,
		Repo:        task.Repo,
		IssueNumber: task.IssueNumber,
	}

	if err := e.taskStore.Create(storeTask); err != nil {
		log.Printf("Warning: failed to create task in store: %v", err)
	}

	e.logTask(taskID, "info", fmt.Sprintf("Starting task for %s/%s#%d", task.Owner, task.Repo, task.IssueNumber))
	e.taskStore.UpdateStatus(taskID, store.StatusRunning)

	// Step 1: Clone repository
	e.logTask(taskID, "info", "Cloning repository...")
	repoPath, err := e.ghOps.CloneRepository(ctx, task.Owner, task.Repo)
	if err != nil {
		return e.notifyError(task, taskID, fmt.Sprintf("Failed to clone repository: %v", err))
	}
	defer os.RemoveAll(repoPath)
	e.logTask(taskID, "success", fmt.Sprintf("Repository cloned to %s", repoPath))

	// Step 2: Generate code
	e.logTask(taskID, "info", "Generating code with AI provider...")
	req := &provider.CodeGenerationRequest{
		RepoPath:    repoPath,
		IssueTitle:  task.IssueTitle,
		IssueBody:   task.IssueBody,
		IssueNumber: task.IssueNumber,
	}

	resp, err := e.provider.GenerateCode(ctx, req)
	if err != nil {
		return e.notifyError(task, taskID, fmt.Sprintf("AI provider failed: %v", err))
	}
	e.logTask(taskID, "success", "Code generation completed")

	// Step 3: Apply changes
	e.logTask(taskID, "info", "Applying file changes...")
	if err := e.applyChanges(repoPath, resp.Changes); err != nil {
		return e.notifyError(task, taskID, fmt.Sprintf("Failed to apply changes: %v", err))
	}
	e.logTask(taskID, "success", fmt.Sprintf("Applied %d file changes", len(resp.Changes)))

	// Step 4: Commit and push
	e.logTask(taskID, "info", "Creating branch and committing changes...")
	branchName := fmt.Sprintf("pilot/issue-%d", task.IssueNumber)
	commitMsg := fmt.Sprintf("feat: %s\n\nFixes #%d\n\nGenerated by Pilot SWE", task.IssueTitle, task.IssueNumber)

	if err := e.commitAndPush(ctx, repoPath, branchName, commitMsg, task); err != nil {
		return e.notifyError(task, taskID, fmt.Sprintf("Failed to commit/push: %v", err))
	}
	e.logTask(taskID, "success", "Changes committed and pushed")

	// Step 5: Create PR(s) and notify
	e.logTask(taskID, "info", "Creating pull request(s)...")
	prURLs, err := e.ghOps.CreatePullRequests(ctx, task.Owner, task.Repo, branchName, "main", resp.Summary, task.IssueNumber)
	if err != nil {
		return e.notifyError(task, taskID, fmt.Sprintf("Failed to create PR: %v", err))
	}

	for _, prURL := range prURLs {
		e.taskStore.AddPRURL(taskID, prURL)
		e.logTask(taskID, "success", fmt.Sprintf("Created PR: %s", prURL))
	}

	// Post success comment
	comment := e.formatSuccessComment(task, prURLs)
	if err := e.ghOps.PostComment(ctx, task.Owner, task.Repo, task.IssueNumber, comment); err != nil {
		log.Printf("Failed to post success comment: %v", err)
	}

	e.taskStore.UpdateStatus(taskID, store.StatusCompleted)
	e.logTask(taskID, "success", "Task completed successfully")
	return nil
}

func (e *Executor) applyChanges(repoPath string, changes []provider.FileChange) error {
	for _, change := range changes {
		filePath := filepath.Join(repoPath, change.Path)

		// Create directory if needed
		dir := filepath.Dir(filePath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}

		// Write file
		if err := os.WriteFile(filePath, []byte(change.Content), 0644); err != nil {
			return fmt.Errorf("failed to write file %s: %w", filePath, err)
		}
	}
	return nil
}

func (e *Executor) commitAndPush(ctx context.Context, repoPath, branchName, commitMsg string, task *Task) error {
	cmds := []struct {
		name string
		args []string
	}{
		{"git", []string{"config", "user.name", "Pilot SWE"}},
		{"git", []string{"config", "user.email", "pilot@stellarlink.ai"}},
		{"git", []string{"checkout", "-b", branchName}},
		{"git", []string{"add", "."}},
		{"git", []string{"commit", "-m", commitMsg}},
		{"git", []string{"push", "origin", branchName}},
	}

	for _, cmd := range cmds {
		if err := e.ghOps.RunCommand(ctx, repoPath, cmd.name, cmd.args...); err != nil {
			return err
		}
	}

	return nil
}

func (e *Executor) formatSuccessComment(task *Task, prURLs []string) string {
	var comment strings.Builder
	comment.WriteString(fmt.Sprintf("✅ **Pilot finished @%s's task**\n", task.User))
	comment.WriteString("---\n\n")

	if len(prURLs) == 1 {
		comment.WriteString(fmt.Sprintf("**Pull Request:** %s\n\n", prURLs[0]))
	} else {
		comment.WriteString("**Pull Requests:**\n")
		for i, url := range prURLs {
			comment.WriteString(fmt.Sprintf("%d. %s\n", i+1, url))
		}
		comment.WriteString("\n")
	}

	comment.WriteString("*Generated by Pilot SWE*")
	return comment.String()
}

func (e *Executor) notifyError(task *Task, taskID, errMsg string) error {
	e.taskStore.UpdateStatus(taskID, store.StatusFailed)
	e.taskStore.SetError(taskID, errMsg)
	e.logTask(taskID, "error", errMsg)

	comment := fmt.Sprintf("❌ **Pilot encountered an error**\n\n```\n%s\n```\n\n*Task ID: %s*", errMsg, taskID)
	if err := e.ghOps.PostComment(context.Background(), task.Owner, task.Repo, task.IssueNumber, comment); err != nil {
		log.Printf("Failed to post error comment: %v", err)
	}

	return fmt.Errorf(errMsg)
}

func (e *Executor) logTask(taskID, level, message string) {
	if err := e.taskStore.AppendLog(taskID, level, message); err != nil {
		log.Printf("Failed to append log: %v", err)
	}
}

func generateTaskID(task *Task) string {
	return fmt.Sprintf("%s-%s-%d-%s", task.Owner, task.Repo, task.IssueNumber, uuid.New().String()[:8])
}